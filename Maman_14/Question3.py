# //////////////////////////////////////////////////////
# //////////// Question 3  /////////////////
# //////////////////////////////////////////////////////

# Task -            Write a function that takes 2d array and x,y and checks if there is combination  of at least 2 object that are 
#                   touching each other. That function returns the number of touching objects, if there is no combination
#                   (at least 2) then the function return 0

# Plan -            Checks the x,y given as arg and checking if it = 1, if it does then check all the directions (8) recursively
#                   and add +1 to counter. At the end it return all of the surrounding objects.

# Time complexity - O(n^2)

# Code - 

class ex14():
    def __init__(self):
        """
        Initializes the Ex14 Q3 class.
        - array: 2D array generated by create_2d_array.
        - combination_size: Tracks the size of the combination.
        - checked_objects: List to store checked (x, y) positions.
        - array_size: Size of the array.
        """
        self.array              = create_2d_array(5)
        self.combination_sum    = 0
        self.checked_objects    = []
        self.array_size         = len(self.array) - 1
        print(self.array)

    def _rec_size(self, x : int, y : int) -> int:
        '''
        Calculate the size of the combination (at least 2 touching objects).

        Args:
        - x (int):  Row (x) of the array.
        - y (int):  Colum (y) of the array.

        Returns:
        - combination_sum (int): Sum of combinations.
        '''
        # Check if the position is out of range or is zero.
        if self.is_out_of_range(x,y) or self.is_zero(x,y):
            return
        
        # If the position is not in the list of checked objects, add it and increment combination_size
        if self.is_notincheckedobject(x,y):
            self.checked_objects.append((x,y))
            self.combination_sum += 1

        # Define directions to explore adjacent positions and return the result of processing them recursively
        directions = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]
        return self.process_directions(x, y, directions)

    def process_directions(self, x, y, directions):
        '''
        Recursively explores the neighboring directions and updates the combination_size.

        Args:
        - x (int): Row (x) of the array.
        - y (int): Column (y) of the array.
        - directions (list): List of directions to explore.

        Returns:
        - combination_size (int): Sum of combinations.
        '''
        if not directions:
            return

        dx, dy = directions[0]
        new_x, new_y = x + dx, y + dy
        if self.check_dir(new_x, new_y):
            self.combination_sum += 1

        return self.process_directions(x, y, directions[1:])
    
    def is_notincheckedobject(self,x,y):
        '''
        Checks given x,y that it is in the checked objects list.

        Args:
        - x (int):  Row (x) of the array.
        - y (int):  Colum (y) of the array.

        Returns:
        - (bool): Whether (x, y) is not in the checked objects list.
        '''
        return (x,y) not in self.checked_objects
    
    def is_out_of_range(self,x,y):
        '''
        Checks given x,y that it is range of the array.

        Args:
        - x (int):  Row (x) of the array.
        - y (int):  Colum (y) of the array.

        Returns:
        - (bool): Whether (x, y) is out of range.
        '''
        return not (0 <= x <= self.array_size) or not (0 <= y <= self.array_size)
        
    def is_zero(self,x,y):
        '''
        Checks if the given object is zero.

        Args:
        - x (int):  Row (x) of the array.
        - y (int):  Colum (y) of the array.

        Returns:
        - (bool): Whether the object at (x, y) is zero.
        '''
        return self.array[x][y] == 0

    def check_dir(self,x,y):
        '''
        Checks the new direction at (x, y) against certain conditions.
        
        Args:
        - x (int): Row (x) of the array.
        - y (int): Column (y) of the array.

        Returns:
        - (bool): Whether the conditions are met.
        '''
        if self.is_out_of_range(x,y):
            return False
        if self.array[x][y] == 1 and self.is_notincheckedobject(x,y):
            self.checked_objects.append((x,y))
            self._rec_size(x,y)
            return True
        return False
    
    def size(self,x,y):
        '''
        Call the main size recursive function, check and update the combination sum if it hasnt reached min combinations.

        Args:
        - x (int): Row (x) of the array.
        - y (int): Column (y) of the array.

        Returns:
        - combination_size (int): Sum of combinations.
        '''
        self._rec_size(x,y)
        if self.combination_sum < 2:
            self.combination_sum = 0
        return self.combination_sum

    
a = ex14()
print(a.size(4,3))


